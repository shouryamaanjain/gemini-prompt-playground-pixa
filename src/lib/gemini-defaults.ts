export const DEFAULT_PROMPT = `You are an expert Hindi speech analysis and transcription system for TTS (Text-to-Speech) training data curation.

Your task:
1. Listen to the audio segment carefully
2. Transcribe the speech in Hindi Devanagari script
3. Evaluate the segment across multiple quality metrics
4. Return structured JSON output with all metrics

TRANSCRIPTION RULES:
- Transcribe in pure Devanagari script (no romanization)
- Include punctuation (\u0964, ?, !, etc.)
- If speech is unintelligible, transcribe whatever you can make out

METRIC DEFINITIONS:

single_speaker: Is there exactly one speaker in this segment? Answer true only if a single person is speaking throughout. Answer false if there are overlapping voices, a conversation between people, or multiple distinct speakers.

speaker_gender: Identify the gender of the primary speaker. Use "male" or "female".

noise_level: Rate the intensity and presence of the background environment. "no_noise" = the background is effectively silent, the listener focuses solely on the voice with no perceptible environmental ambience. "low" = there is a noticeable background presence or steady ambience (a "room tone" or "outdoor drone") that is clearly audible throughout, but the speech remains distinct and dominant. "high" = the background is loud, chaotic, or contains impulsive sounds that compete with the speaker's volume or make the speech difficult to process.

is_artificially_generated: Does the speech sound like it was generated by a text-to-speech system or AI voice? Answer true if the voice sounds synthetic, robotic, or artificially generated. Answer false if it sounds like a natural human voice.

speaking_pace: Evaluate the speed of speech. "very_slow" = unnaturally slow, drawn out. "slow" = slower than normal conversation. "normal" = natural conversational speed. "fast" = noticeably faster than normal but still intelligible. "very_fast" = extremely fast, rushed, hard to follow.

language_category: Classify the language used in the segment. "only_hindi" = traditional/original Hindi with Sanskritic vocabulary, formal or literary Hindi. "hinglish" = significant mixing of Hindi and English words/phrases within sentences. "english" = primarily English speech.

recording_quality: Classify the technical fidelity and acoustic properties of the recording. "studio" = professional-grade audio, characterized by close microphone proximity, high fidelity, rich vocal presence, and a complete absence of room acoustics (no echo/reverb). "low_quality" = consumer-grade or compromised audio, characterized by audible room reverberation (echo), distant microphone placement ("thin" voice), digital compression artifacts, or technical distortion, regardless of the environmental noise level.

word_cutoff: Are there any words cut off at the start or end of the segment? Answer true if the audio begins or ends mid-word, making any word incomplete. Answer false if all words at the boundaries are complete.

transcript: The Hindi Devanagari transcription of the spoken content.`;

export const DEFAULT_SCHEMA = {
  type: "object",
  properties: {
    single_speaker: { type: "boolean", description: "True if exactly one speaker is present, false if multiple or overlapping voices" },
    speaker_gender: { type: "string", enum: ["male", "female"], description: "Gender of the primary speaker" },
    noise_level: { type: "string", enum: ["no_noise", "low", "high"], description: "Background noise intensity level" },
    is_artificially_generated: { type: "boolean", description: "True if the speech sounds synthetic or AI-generated" },
    speaking_pace: { type: "string", enum: ["very_slow", "slow", "normal", "fast", "very_fast"], description: "Speed of speech delivery" },
    language_category: { type: "string", enum: ["only_hindi", "hinglish", "english"], description: "Language classification of the spoken content" },
    recording_quality: { type: "string", enum: ["studio", "low_quality"], description: "Recording environment quality: studio-grade or low-quality casual recording" },
    word_cutoff: { type: "boolean", description: "True if words are cut off at the start or end of the segment" },
    transcript: { type: "string", description: "Hindi Devanagari transcription of the speech" },
  },
  required: [
    "single_speaker", "speaker_gender", "noise_level",
    "is_artificially_generated", "speaking_pace", "language_category",
    "recording_quality", "word_cutoff", "transcript",
  ],
};

export const DEFAULT_SCHEMA_JSON = JSON.stringify(DEFAULT_SCHEMA, null, 2);

export const HARM_CATEGORIES = [
  { value: "HARM_CATEGORY_HARASSMENT", label: "Harassment" },
  { value: "HARM_CATEGORY_HATE_SPEECH", label: "Hate Speech" },
  { value: "HARM_CATEGORY_SEXUALLY_EXPLICIT", label: "Sexually Explicit" },
  { value: "HARM_CATEGORY_DANGEROUS_CONTENT", label: "Dangerous Content" },
] as const;

export const HARM_THRESHOLDS = [
  { value: "OFF", label: "Off" },
  { value: "BLOCK_NONE", label: "Block None" },
  { value: "BLOCK_ONLY_HIGH", label: "Block Few" },
  { value: "BLOCK_MEDIUM_AND_ABOVE", label: "Block Some" },
  { value: "BLOCK_LOW_AND_ABOVE", label: "Block Most" },
] as const;

export interface SafetySetting {
  category: string;
  threshold: string;
}

export interface GeminiApiParams {
  thinkingLevel: "low" | "high";
  mediaResolution: "MEDIA_RESOLUTION_UNSPECIFIED" | "MEDIA_RESOLUTION_LOW" | "MEDIA_RESOLUTION_MEDIUM" | "MEDIA_RESOLUTION_HIGH" | null;
  googleSearch: boolean;
  urlContext: boolean;
  safetySettings: SafetySetting[];
}

export const DEFAULT_API_PARAMS: GeminiApiParams = {
  thinkingLevel: "high",
  mediaResolution: null,
  googleSearch: false,
  urlContext: false,
  safetySettings: [],
};

export interface GeminiConfig {
  prompt: string;
  schemaJson: string;
  params: GeminiApiParams;
}

export function buildDefaultConfig(): GeminiConfig {
  return {
    prompt: DEFAULT_PROMPT,
    schemaJson: DEFAULT_SCHEMA_JSON,
    params: { ...DEFAULT_API_PARAMS, safetySettings: [] },
  };
}

// Dynamic field derived from schema JSON for the assessment form
export interface SchemaField {
  key: string;
  label: string;
  type: "boolean" | "enum";
  options?: string[];
}

export function parseSchemaFields(schemaJson: string): SchemaField[] {
  try {
    const schema = JSON.parse(schemaJson);
    if (!schema.properties || typeof schema.properties !== "object") return [];

    const fields: SchemaField[] = [];
    for (const [key, prop] of Object.entries(schema.properties)) {
      const p = prop as Record<string, unknown>;
      if (p.type === "boolean") {
        fields.push({ key, label: humanize(key), type: "boolean" });
      } else if (p.type === "string" && Array.isArray(p.enum) && p.enum.length > 0) {
        fields.push({ key, label: humanize(key), type: "enum", options: p.enum as string[] });
      }
      // Skip plain strings (e.g. transcript), numbers, etc. â€” those are Gemini-only output
    }
    return fields;
  } catch {
    return [];
  }
}

function humanize(key: string): string {
  const s = key.replace(/_/g, " ");
  return s.charAt(0).toUpperCase() + s.slice(1);
}
